---
title: "STM32 Bare Metal Programming"
date: 2020-05-30
categories:
  - mcu
tags:
  - mcu
  - stm32
  - embedded
toc: true
toc_label : "Table of Contents"
---

# Introduction

There are many software development kits for microcontroller applications, such as STM32 CubeMX, TI Code Composer Studio and Keil MDK which provide GUI interfaces to initialize, build and debug the code.
They can apply an abstraction by using high-level libraries and OS integration.
All these make the learning curve steep, enables fast initial development and allows a better portability in the same vendor devices.

On the other hand, hiding the low level implementation details by the high abstraction levels reduce the level of control on the MCU.
These abstractions and automatized tools remove the necessity of learning how MCU works, but they brings a restriction of tool-dependent development.
Sometimes changing the initial settings is not straightforward and you may prefer to make the change in the GUI and re-generate the design.
Even more, they may need a paid license.

Low-level programming by accessing registers, using the toolchain by a *Makefile*, debugging with *gdb* and a good text editor provide a very powerful development environment with a reasonable effort and no cost.
In this bare-metal programming, any abstraction is not used and direct access to the MCU registers is made.
Thus the fastest operation with cycle accuracy which is critical in real-time systems can be achieved.
This also brings better control and comprehension on the implementation.
Moreover, text based development is more reliable, repeatable comparing to GUI clicking based development.

In this post, I will give a basic introduction to the bare-metal programming.
I will use a minimum set of documents and tools from the primary resources and share source codes for the most common tasks.
For the hardware experiments, I choose a low-cost hardware with a simple ARM Cortex-M0:
* STM32 F0 Discovery board with STM32F051R8T6
  - Frequency up to 48 MHz
  - Two I2C interfaces
  - Two USARTs
  - No external crystal oscillator
  - Internal 8 MHz RC with x6 PLL option
But the approach can be applied to any MCU.

Firstly I will describe my workspace - directory structure and tools, 
and then I will share my experiments to control peripherals with code snippets.
I will also explain how I acquired the information from the official documents.
Of course this blog post is quite far from to explain everything, please refer to the documents mentioned in the text for further information.

# Workspace


## Directory structure

Top level workspace directory:

```
stm32/f0/
├── bin/
├── doc/
├── proj/
├── STM32CubeF0/
├── STM32F0xx_Snippets_Package_V1.2.0/
└── templates/

```

### bin/ 
is to keep the useful tools/scripts.

Content of the ```create_stm32f0_project``` script:

```bash
STM32F0_PROJ_PATH="/home/serg/ws/stm32/f0/proj/"
CMSIS_INC_PATH="/home/serg/ws/stm32/f0/STM32CubeF0/Drivers/CMSIS/Core/Include/"
ST_DEV_PATH="/home/serg/ws/stm32/f0/STM32CubeF0/Drivers/CMSIS/Device/ST/STM32F0xx/"
SE_TOOL_PATH="/home/serg/ws/stm32/f0/setool/"

if [ -z "$1" ]; then
	echo "Project name is missing."
	exit
fi
 
mkdir -p $STM32F0_PROJ_PATH/$1
mkdir -p $STM32F0_PROJ_PATH/$1/bin
mkdir -p $STM32F0_PROJ_PATH/$1/inc
mkdir -p $STM32F0_PROJ_PATH/$1/linker
mkdir -p $STM32F0_PROJ_PATH/$1/src
mkdir -p $STM32F0_PROJ_PATH/$1/obj

cp $CMSIS_INC_PATH/cmsis_compiler.h $STM32F0_PROJ_PATH/$1/inc/
cp $CMSIS_INC_PATH/core_cm0.h $STM32F0_PROJ_PATH/$1/inc/
cp $CMSIS_INC_PATH/cmsis_gcc.h $STM32F0_PROJ_PATH/$1/inc/
cp $CMSIS_INC_PATH/cmsis_version.h $STM32F0_PROJ_PATH/$1/inc/

cp $ST_DEV_PATH/Include/stm32f0xx.h $STM32F0_PROJ_PATH/$1/inc/
cp $ST_DEV_PATH/Include/stm32f051x8.h $STM32F0_PROJ_PATH/$1/inc/
cp $ST_DEV_PATH/Include/system_stm32f0xx.h $STM32F0_PROJ_PATH/$1/inc/

cp $ST_DEV_PATH/Source/Templates/system_stm32f0xx.c $STM32F0_PROJ_PATH/$1/src/
cp $ST_DEV_PATH/Source/Templates/gcc/startup_stm32f051x8.s $STM32F0_PROJ_PATH/$1/src/

cp $SE_TOOL_PATH/main.c $STM32F0_PROJ_PATH/$1/src/
cp $SE_TOOL_PATH/Makefile $STM32F0_PROJ_PATH/$1/
cp $SE_TOOL_PATH/.gitignore $STM32F0_PROJ_PATH/$1/
cp $SE_TOOL_PATH/STM32F051R8Tx_FLASH.ld $STM32F0_PROJ_PATH/$1/

cd $STM32F0_PROJ_PATH/$1/
git init
```

### doc/

Minimum these 3 files should be in this directory:

  * **Reference Manual**

    * Peripherals, registers.
    * [Reference manual STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM®-based 32-bit MCUs](https://www.st.com/resource/en/reference_manual/dm00031936-stm32f0x1stm32f0x2stm32f0x8-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)

  * **Datasheet**

    * Alternate functions table: AF numbers 
    * Peripheral register boundary addresses 
    * Clock tree
    * PLL characteristics - input/output clock frequency

  * **Board schematics**

    * MCU pin - Header connections


### proj/

A project directory:

```
project_name/
├── bin/
│   ├── main.bin
│   └── main.elf
├── inc/
│   ├── cmsis_compiler.h
│   ├── cmsis_gcc.h
│   ├── cmsis_version.h
│   ├── core_cm0.h
│   ├── stm32f051x8.h
│   ├── stm32f0xx.h
│   └── system_stm32f0xx.h
├── linker/
│   └── STM32F051R8Tx_FLASH.ld
├── Makefile
├── obj/
│   ├── main.d
│   ├── main.o
│   ├── startup_stm32f051x8.o
│   ├── STM32F411xE.o
│   ├── system_stm32f0xx.d
│   ├── system_stm32f0xx.o
│   ├── system_stm32f4xx.d
│   └── system_stm32f4xx.o
└── src/
    ├── main.c
    ├── startup_stm32f051x8.s
    └── system_stm32f0xx.c

```


### STM32CubeF0/

git clone of STM32CubeF0 repository.
It includes CMSIS modules as well as HALL-LL drivers, BSP drivers etc.
In the bare-metal programming, I will use only CMSIS modules which is located at `Drivers/CMSIS`.


```
git clone https://github.com/STMicroelectronics/STM32CubeF0
```

### STM32F0xx_Snippets_Package_V1.2.0/


Free example source codes of  for the STM32F0 family provided by ST.

[STM32F0 code snippets](https://www.st.com/en/embedded-software/stm32snippetsf0.html)

### inc/

Headers. The minimum set of file is:

ARM core headers:

* **cmsis_compiler.h**
  - `#include <stdint.h>`
  - `#include "cmsis_armcc.h"`
  - `#define __ASM  __asm`
  - `#define __INLINE  inline`
* **cmsis_gcc.h**
* **cmsis_version.h**
* **core_cm0.h**
  - Cortex-M0 processor and core peripherals
  - NVIC
    - NVIC_Type
    - NVIC_EnableIRQ, NVIC_DisableIRQ, NVIC_SetPriority
  - CMSIS_SysTick
    - SysTick_Config(uint32_t ticks)

MCU specific headers from ST:

* **stm32f0xx.h**
* **stm32f051x8.h**
- Peripheral registers:
  - ADC_TypeDef, FLASH_TypeDef, GPIO_TypeDef, RCC_TypeDef, TIM_TypeDef, I2C_TypeDef
  - Register addresses
  - Bit positions
- IRQ numbers: IRQn_Type
* **system_stm32f0xx.h**
```c
#include "stm32f051x8.h"
```
* **system_stm32f0xx.c**
```c 
extern uint32_t SystemCoreClock;
```
* **startup_stm32f051x8.s**
- g_pfnVectors: interrupt vector table
- Exception handlers: SysTick_Handler, TIM3_IRQHandler, EXTI0_1_IRQHandler

Source files:

- main.c

* Copy only the necessary library files from STM32CubeF0 into the project folder.
* A base project can be created by the script: `create_stm32f0_project`.




## Tools

### Compile

GNU Arm Embedded Toolchain

The toolchains support code generation for non-OS or 'bare-metal' environments.

* arm-none-eabi-gcc
* arm-none-eabi-ld
* arm-none-eabi-ar
* arm-none-eabi-as
* arm-none-eabi-objcopy
* arm-none-eabi-objdump


The compilation can be automatized with a Makefile below:

```make
# ---------------------------------------- 
# Hardware
DEVICE       = STM32F051x8
MCU          = cortex-m0
ARCH         = armv6-m
FLASH_BASE   = 0x08000000
FLASH_OFFSET = 0
# ---------------------------------------- 
# Directories
SRC_DIR      = ./src
INC_DIR      = ./inc
LNK_DIR      = ./linker
BIN_DIR      = ./bin
OBJ_DIR      = ./obj
# ---------------------------------------- 
# Toolchain
CC           = arm-none-eabi-gcc
LD           = arm-none-eabi-ld
AR           = arm-none-eabi-ar
AS           = arm-none-eabi-as
CP           = arm-none-eabi-objcopy
OD           = arm-none-eabi-objdump
# ---------------------------------------- 
# Target files
TARGET       = main
BIN          = $(BIN_DIR)/$(TARGET).bin
EXECUTABLE   = $(BIN_DIR)/$(TARGET).elf
# ---------------------------------------- 
# Input files
LDSCRIPT     = linker/STM32F051R8Tx_FLASH.ld
SRC          = $(wildcard $(SRC_DIR)/*)
INC          = -I$(INC_DIR)
# ---------------------------------------- 
# Seperate C and asm files
CFILES       = $(filter %.c, $(SRC))
ASMFILES     = $(filter %.s, $(SRC))
# ---------------------------------------- 
# Object files
#COBJ         = $(CFILES:.c=.o)
COBJ         = $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(CFILES))
#SOBJ         = $(ASMFILES:.s=.o)
SOBJ         = $(patsubst $(SRC_DIR)/%.s, $(OBJ_DIR)/%.o, $(ASMFILES))
OBJ          = $(COBJ) $(SOBJ)
# ---------------------------------------- 
# Compiler flags
# ---------------------------------------- 
## Compiler flags
LDFLAGS      = -T$(LDSCRIPT),--gc-sections 
LDFLAGS     += -lm

MCFLAGS      = -mcpu=$(MCU) 
MCFLAGS     += -mthumb 
MCFLAGS     += -mlittle-endian 
MCFLAGS     += -mthumb-interwork
MCFLAGS     += -march=$(ARCH)

OPTIMIZE     = -O3 
OPTIMIZE    += -fdata-sections 
OPTIMIZE    += -ffunction-sections 
OPTIMIZE    += -fsingle-precision-constant

DEBUG        = -g3

CFLAGS       = $(MCFLAGS) $(DEBUG)  $(OPTIMIZE) -MP -MMD
ASFLAGS      = $(MCFLAGS) $(DEBUG)
# ---------------------------------------- 
# Defines to be passed to the compiler
DEFINES     = -D$(DEVICE) \
              -DVECT_TAB_OFFSET=$(FLASH_OFFSET)
# ---------------------------------------- 
all: $(BIN)

$(BIN): $(EXECUTABLE)
	$(CP) -O binary $^ $@

$(EXECUTABLE): $(OBJ) $(LDSCRIPT)
	$(CC) $(CFLAGS) $(sort $(OBJ)) -Wl,$(LDFLAGS) -o $@

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	mkdir -p $(OBJ_DIR)
	$(CC) -c $(DEFINES) $(INC) $(CFLAGS) $< -o $@

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.s
	$(AS) -c $(ASFLAGS) $(INC) $< -o $@

clean:
	rm -f $(OBJ) $(BIN) $(EXECUTABLE)

flash:
	st-flash write $(BIN) $(FLASH_BASE)
```




### Debug

OpenOCD (Open On-Chip Debugger) provides debugging, in-system programming and boundary-scan testing for embedded devices. 
It also allows GDB debug and Flash programming of STM32 based cores.
OpenOCD can be installed by using apt in Ubuntu:

```
sudo apt-get install openocd
```

When OpenOCD is run with the related configuration file, gdb debug can be started on the board:
```
openocd -f /usr/share/openocd/scripts/board/st_nucleo_f0.cfg
```

* gdb

```
arm-none-eabi-gdb -q ./main.elf

(gdb) target remote localhost:3333
```    

``` 
$ arm-none-eabi-gdb example.elf
(gdb) target remote localhost:3333
Remote debugging using localhost:3333
...
(gdb) monitor reset halt
...
(gdb) load
Loading section .vectors, size 0x100 lma 0x20000000
Loading section .text, size 0x5a0 lma 0x20000100
Loading section .data, size 0x18 lma 0x200006a0
Start address 0x2000061c, load size 1720
Transfer rate: 22 KB/sec, 573 bytes/write.
(gdb) continue

b 24

p/x RCC->CR

4 0000
```

# Processor core

(in progress)


## SYSTICK

* Main timer
* Coundown, 24-bit.

`core_cm0.h`

```c
#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
```

```c
typedef struct
{
  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
} SysTick_Type;
```

IRQ handler is defined in the startup file:

```asm
  .word  SysTick_Handler
```


## NVIC

Nested Vector Interrupt Controller

* Supports up to 240 interrupt sources.
* 256 priority levels.


* NVIC is connected to the vector table at the beginning of the code region.
* Interrupt -> current state of the exec app is pushed to stack and ISR is executed.
* If one or more int's occurs while in an ISR, pull op is canceled and fetch the second ISR



NVIC type is defined in core_cm4.h:
```c
typedef struct
{
  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
        uint32_t RESERVED0[24U];
  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
        uint32_t RSERVED1[24U];
  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
        uint32_t RESERVED2[24U];
  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
        uint32_t RESERVED3[24U];
  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
        uint32_t RESERVED4[56U];
  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
        uint32_t RESERVED5[644U];
  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
}  NVIC_Type;
```

* NVIC addresses are defined in core_cm4.h:

```c

#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */

```

* NVIC functions

```c
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}
```

```c
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    __DSB();
    __ISB();
  }
}
```



```c
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
```



* IRQn's are defined in stm32f411xe.h:


```c

typedef enum
{
/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
/******  STM32 specific Interrupt Numbers **********************************************************************/
  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
 
 ...
 
 
  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
  ...
  
  } IRQn_Type;

```


* Handlers are located in the startup file:


```assembly

g_pfnVectors:
  .word  _estack
  .word  Reset_Handler
  .word  NMI_Handler
  .word  HardFault_Handler

/* External Interrupts */
  .word     WWDG_IRQHandler                   /* Window WatchDog              */                                        
  .word     PVD_IRQHandler                    /* PVD through EXTI Line detection */                        
  ...
  .word     TIM2_IRQHandler                   /* TIM2 (pos 28)                        */                   
  .word     TIM3_IRQHandler                   /* TIM3 (pos 29)                        */                   
```





# Peripherals

## RCC

Reset and Clock Control

Clock distribution

refer clock tree

* RCC struct is defined in stm32f411xe.h:

```c
typedef struct
{
  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
  uint32_t      RESERVED7[1];  /*!< Reserved, 0x88                                                                    */
  __IO uint32_t DCKCFGR;       /*!< RCC Dedicated Clocks configuration register,                 Address offset: 0x8C */
} RCC_TypeDef;
```


* Address:

```c
#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800UL)
```


* Its registers are also defined in the same file.


```c
__INLINE void rcc_sysclk_hsi(void)
{
    uint32_t reg32;

    // Select system clock HSI
    reg32 = RCC->CFGR;
    reg32 &= ~RCC_CFGR_SW_Msk;
    RCC->CFGR = reg32 | RCC_CFGR_SW_HSI << RCC_CFGR_SW_Pos;

    // HSI oscillator on
    // HSI frequency : 8 MHz
    RCC->CR |= RCC_CR_HSION;
    while ((RCC->CR & RCC_CR_HSIRDY) == 0);
}
```


```c
__INLINE void rcc_sysclk_pll_hsi(void)
{
    uint32_t reg32;

    // HSI oscillator (8 MHz) clock selected as PLL clock entry
    reg32 = RCC->CFGR;
    reg32 &= ~RCC_CFGR_PLLSRC_Msk;
    RCC->CFGR = reg32 | RCC_CFGR_PLLSRC_HSI_DIV2 << RCC_CFGR_PLLSRC_Pos;

    // PLL multiplication factor for VCO
    // The PLL output frequency must be set in the range 16-48 MHz.
    reg32 = RCC->CFGR;
    reg32 &= ~RCC_CFGR_PLLMUL_Msk;
    RCC->CFGR = reg32 | RCC_CFGR_PLLMUL12;

    // Main PLL enable
    RCC->CR |= RCC_CR_PLLON;
    // wait until the output is stable:
    while ((RCC->CR & RCC_CR_PLLRDY) == 0);

    // Select system clock: PLL
    reg32 = RCC->CFGR;
    reg32 &= ~RCC_CFGR_SW_Msk;
    RCC->CFGR = reg32 | RCC_CFGR_SW_PLL << RCC_CFGR_SW_Pos;

    // Wait until the PLL is switched on
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}
```




## TIMER

Usually timers are used for:

* Interrupts: Running periodic operations
* PWM: Generating output waveforms
* Input capture: Measuring the pulse length of input signals

When the counter enabled in the up-counting mode, the interrupt based operation is as follows:

* Counter clock is divided by PSC (prescaler) register.
* When counter register reaches ARR (Auto Reload Register):
  * Counter register is reset.
  * UIF (Update Interrupt Flag) rises high.
  * Timer ISR (Interrupt Request Handler) is called, if related interrupt enable bit is set.
  * UIF must be cleared in the handler to allow the following interrupts. 

PWM output mode:

* Period of PWM: ARR, duty cycle: CCR Capture and compare registers
* if CNT < CCR then OUT = 0, else OUT = 1.
* When CNT = ARR, then CNT = 0.
* This polarity can be changed by OCM (Output Control Mode).

From the pin definitions table and alternate functions table of the datasheet, the alternate function numbers of the pins can be found.
In my example, the user LED is connected to PC9 and its only alternate function is TIM3_CH4. Therefore, in order to activate it:
* Switch to alterate function mode with MODER (Mode Register).
* Select PWM Mode 1: out is H as long as TIMx_CNT<TIMx_CCR4 else L
* Enable Timer 3
* Enable Channel 4

**Snippets:**

Set GPIO - PC9 as out:

```c
__INLINE void gpio_pc9_out(void)
{
	// Enable the peripheral clock of GPIOC
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN;

	// Select output mode (01) on PC9
	GPIOC->MODER &= ~GPIO_MODER_MODER9_Msk;
	GPIOC->MODER |= GPIO_MODER_MODER9_0;
}
```

Set GPIO - PC9 alternate mode:

```c
__INLINE void gpio_pc9_pwm(void)
{
	uint32_t reg32;

    // Enable GPIOC peripheral
    RCC->AHBENR |= RCC_AHBENR_GPIOCEN;

	// Pin 5 to alternative function mode: tim3ch4
	reg32 = GPIOC->MODER;
	reg32 &= ~GPIO_MODER_MODER9_Msk;
	GPIOC->MODER = reg32 | 2 << GPIO_MODER_MODER9_Pos;
}
```

PWM settings with TIM3_CH4:

```c
void tim3_ch4_pwm(uint32_t arr, uint32_t ccr4)
{
	// tim3ch4
	uint32_t reg32;

	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

	TIM3->PSC = 1;
	TIM3->ARR = arr;
	TIM3->CCR4 = ccr4;

	TIM3->CR2 = TIM_CR2_MMS_0 | TIM_CR2_MMS_1 | TIM_CR2_MMS_2;

	// PWM Mode 1: out is H as long as TIMx_CNT<TIMx_CCR4 else L
	reg32 = TIM3->CCMR2;
	reg32 &= ~TIM_CCMR2_OC4M_Msk;
	TIM3->CCMR2 = reg32 | 6 << TIM_CCMR2_OC4M_Pos;
	TIM3->CCMR2 |= TIM_CCMR2_OC4CE;

	// Enable CH4 of TIM3
	TIM3->CCER |= TIM_CCER_CC4E;
	
	TIM3->CR1 |= TIM_CR1_CEN;
}
```

Enable timer interrupt of TIM3_CH1:

```c
__INLINE void tim3_ch1_irq()
{
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
	TIM3->PSC = 1;
	TIM3->ARR = 96;

	// Enable TIM3
	TIM3->CCER |= TIM_CCER_CC1E;
	TIM3->SR = 0;

	// Start timer counter
	TIM3->CR2 &= 0;

	NVIC_EnableIRQ(TIM3_IRQn);

	TIM3->DIER |= TIM_DIER_UIE;
	TIM3->CR1 |= TIM_CR1_CEN;
}
```



## FLASH





## GPIO

```c
__INLINE void gpio_pa0_in_int(void)
{
    // Enable the peripheral clock of GPIOA
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

    // Select input mode (00) on PA0
    GPIOA->MODER &= ~(GPIO_MODER_MODER0);

    SYSCFG->CFGR1 &= ~SYSCFG_EXTICR1_EXTI0_Msk;

    NVIC_EnableIRQ(EXTI0_1_IRQn);

    EXTI->IMR |= EXTI_IMR_MR0;
    EXTI->EMR |= EXTI_EMR_MR0;
    EXTI->RTSR |= EXTI_RTSR_RT0;
}
```


## ADC


```c
__INLINE void gpio_pa0_adc(void)    // PA0 = ADC IN 0
{
    uint32_t reg32;
    RCC->APB2ENR |= RCC_APB2ENR_ADCEN;
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    GPIOA->MODER |= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER0_1;
    ADC1->SMPR = ADC_SMPR_SMP_0;    // 001: 7.5 ADC clock cycles
    ADC1->CHSELR = ADC_CHSELR_CHSEL0;
    ADC1->CR |= ADC_CR_ADEN;
}

```


```c
int adc_read(void)
{
    ADC1->CR = ADC_CR_ADSTART;
    while(ADC1->CR & ADC_CR_ADSTART);
    while ((ADC1->ISR & ADC_ISR_EOC) == 0);
    return (int) ADC1->DR;
}
```




## DMA

## UART

Alternate function pin map from datasheet:

* PA0-AF1 USART2_CTS
* PA1-AF1 USART2_RTS
* PA2-AF1 USART2_TX
* PA3-AF1 USART2_RX
* PA4-AF1 USART2_CK


```c
__INLINE void uart2_setup(int sys_clk_freq, int uart_baud_rate, char parity)
{
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

	// PA0-AF1 USART2_CTS
	GPIOA->MODER &= ~GPIO_MODER_MODER0_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER0_1;
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL0_Msk;
	GPIOA->AFR[0] |= 1 << GPIO_AFRL_AFSEL0_Pos;

	// PA1-AF1 USART2_RTS
	GPIOA->MODER &= ~GPIO_MODER_MODER1_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER1_1;
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL1_Msk;
	GPIOA->AFR[0] |= 1 << GPIO_AFRL_AFSEL1_Pos;

	// PA2-AF1 USART2_TX
	GPIOA->MODER &= ~GPIO_MODER_MODER2_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER2_1;
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL2_Msk;
	GPIOA->AFR[0] |= 1 << GPIO_AFRL_AFSEL2_Pos;

	// PA3-AF1 USART2_RX
	GPIOA->MODER &= ~GPIO_MODER_MODER3_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER3_1;
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL3_Msk;
	GPIOA->AFR[0] |= 1 << GPIO_AFRL_AFSEL3_Pos;

	// PA4-AF1 USART2_CK
	GPIOA->MODER &= ~GPIO_MODER_MODER4_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL4_Msk;
	GPIOA->AFR[0] |= 1 << GPIO_AFRL_AFSEL4_Pos;

	USART2->BRR = (uint32_t)(sys_clk_freq/uart_baud_rate);
	USART2->CR3 = USART_CR3_HDSEL;

	// Transmitter Enable
	USART2->CR1 |= USART_CR1_TE;
	// Receiver Enable
	USART2->CR1 |= USART_CR1_RE;
	// RXNE Interrupt Enable
	USART2->CR1 |= USART_CR1_RXNEIE;
	// USART Enable
	USART2->CR1 |= USART_CR1_UE;
	// Parity control enable
	USART2->CR1 |= USART_CR1_PCE;

	switch (parity) 
	{
		case 'O':
			// Parity control enable
			USART2->CR1 |= USART_CR1_PCE;
			// PS=1 => odd parity
			USART2->CR1 |= USART_CR1_PS;
			break;
		case 'E':
			// Parity control enable
			USART2->CR1 |= USART_CR1_PCE;
			// PS=0 => even parity
			USART2->CR1 &= ~USART_CR1_PS;
			break;
		default:
			// Parity control enable
			USART2->CR1 |= USART_CR1_PCE;
			// PS=1 => odd parity
			USART2->CR1 |= USART_CR1_PS;
	}
}
```

## SPI


## I2C




